<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<style type="text/css">

   p.desc{
     white-space:nowrap;
   }

   table.pretty {
    margin: 1em 1em 1em 2em;
    background: whitesmoke;
    border-collapse: collapse;
   }

   table.pretty th, table.pretty td {
    border: 1px gainsboro solid;
    padding: 0.2em;
   }

   table.pretty th {
    background: gainsboro;
    text-align: left;
   }

   table.pretty caption {
    margin-left: inherit;
    margin-right: inherit;
    white-space:nowrap;
   }
  </style>
<body>
<h2>Macro Overview</h2>

  The following macros can be overloaded on host level.
  <table class="pretty">
<tr>
<th>Name</th><th>Default</th>
</tr>
</table>
<h1>Static Elements</h1>
<h2>Trigger Overview</h2>
<table class="pretty">
<tr>
<th>Name</th><th>Description</th><th>Priority</th><th>Expression</th><th>Dependencies</th>
</tr>
</table>
<h2>Graph Overview</h2>
<table class="pretty">
<tr>
<th>Name</th><th>Elements</th>
</tr>
</table>
<h2>Item Overview</h2>
<table class="pretty">
<tr>
<th>Type</th><th>Name</th><th>Key</th><th>Description</th><th>Interval (sec)</th><th>History Days</th><th>Trend Days</th>
</tr>
</table>
<h1>Discovery rule "Disk detail discovery"</h1>
<table class="pretty">
<tr>
<th>Name</th><th>Value</th>
</tr>
<tr>
<td>Name</td><td>Disk detail discovery</td>
</tr>
<tr>
<td>Key</td><td>vfs.dev.discovery.detail</td>
</tr>
<tr>
<td>Type</td><td>7</td>
</tr>
<tr>
<td>Delay</td><td>3600</td>
</tr>
</table>
<h2>Trigger Overview</h2>
<table class="pretty">
<tr>
<th>Name</th><th>Description</th><th>Priority</th><th>Expression</th><th>Dependencies</th>
</tr>
</table>
<h2>Graph Overview</h2>
<table class="pretty">
<tr>
<th>Name</th><th>Elements</th>
</tr>
<tr>
<td>Disk {#DEVICENAME} - Bytes/second</td><td><tt>custom.vfs.dev.read.sectors[{#DEVICENAME}]<br>custom.vfs.dev.write.sectors[{#DEVICENAME}]<br>
</tt></td>
</tr>
<tr>
<td>Disk {#DEVICENAME} - IO Queue</td><td><tt>custom.vfs.dev.io.active[{#DEVICENAME}]<br>custom.vfs.dev.queue_depth[{#DEVICENAME}]<br>
</tt></td>
</tr>
<tr>
<td>Disk {#DEVICENAME} - Merged</td><td><tt>custom.vfs.dev.read.merged[{#DEVICENAME}]<br>custom.vfs.dev.write.merged[{#DEVICENAME}]<br>
</tt></td>
</tr>
<tr>
<td>Disk {#DEVICENAME} - Ops/second</td><td><tt>custom.vfs.dev.read.ops[{#DEVICENAME}]<br>custom.vfs.dev.write.ops[{#DEVICENAME}]<br>
</tt></td>
</tr>
</table>
<h2>Item Overview</h2>
<table class="pretty">
<tr>
<th>Type</th><th>Name</th><th>Key</th><th>Description</th><th>Interval (sec)</th><th>History Days</th><th>Trend Days</th>
</tr>
<tr>
<td>7</td><td>$1:IO:Currently Active</td><td><tt>custom.vfs.dev.io.active[{#DEVICENAME}]</tt></td><td>Field #12&#13;
Number of I/Os currently in progress.&#13;
The only field that should go to zero. Incremented as requests are given to appropriate struct request_queue and decremented as they finish.</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:IO:ms</td><td><tt>custom.vfs.dev.io.ms[{#DEVICENAME}]</tt></td><td>Field #13&#13;
Number of milliseconds spent doing I/Os. This field increases so long as field #12 (custom.vfs.dev.io.active) is nonzero.</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:IO:Queue Depth</td><td><tt>custom.vfs.dev.queue_depth[{#DEVICENAME}]</tt></td><td>Field #12&#13;
Number of I/Os currently in progress.&#13;
The only field that should go to zero. Incremented as requests are given to appropriate struct request_queue and decremented as they finish.</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:Read:Merged</td><td><tt>custom.vfs.dev.read.merged[{#DEVICENAME}]</tt></td><td>Field #5&#13;
Number of reads merged.&#13;
Reads and writes which are adjacent to each other may be merged for efficiency. Thus two 4K reads may become one 8K read before it is ultimately handed to the disk, and so it will be counted (and queued) as only one I/O.  This field lets you know how often this was done.</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:Read:ms</td><td><tt>custom.vfs.dev.read.ms[{#DEVICENAME}]</tt></td><td>Field #7&#13;
Number of milliseconds spent reading&#13;
This is the total number of milliseconds spent by all reads (as measured from __make_request() to end_that_request_last()).</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:Read:Ops per second</td><td><tt>custom.vfs.dev.read.ops[{#DEVICENAME}]</tt></td><td>Field #4&#13;
This is the total number of reads completed successfully.</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:Read:Bytes/sec</td><td><tt>custom.vfs.dev.read.sectors[{#DEVICENAME}]</tt></td><td>Field #6&#13;
This is the total number of sectors read successfully.</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:IO:Weight:ms</td><td><tt>custom.vfs.dev.weight.io.ms[{#DEVICENAME}]</tt></td><td>Field #14&#13;
Weighted number of milliseconds spent doing I/Os.&#13;
This field is incremented at each I/O start, I/O completion, I/O merge, or read of these stats by the number of I/Os in progress (field 12) times the number of milliseconds spent doing I/O since the last update of this field.  This can provide an easy measure of both I/O completion time and the backlog that may be accumulating.</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:Write:Merged</td><td><tt>custom.vfs.dev.write.merged[{#DEVICENAME}]</tt></td><td>Field #9&#13;
Number of writes merged.&#13;
Reads and writes which are adjacent to each other may be merged for efficiency. Thus two 4K reads may become one 8K read before it is ultimately handed to the disk, and so it will be counted (and queued) as only one I/O.  This field lets you know how often this was done.</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:Write:ms</td><td><tt>custom.vfs.dev.write.ms[{#DEVICENAME}]</tt></td><td>Field #11&#13;
Number of milliseconds spent writing.&#13;
This is the total number of milliseconds spent by all writes (as measured from __make_request() to end_that_request_last()).</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:Write:Ops per second</td><td><tt>custom.vfs.dev.write.ops[{#DEVICENAME}]</tt></td><td>Field #8&#13;
This is the total number of writes completed successfully.</td><td>60</td><td>7d</td><td>182d</td>
</tr>
<tr>
<td>7</td><td>$1:Write:Bytes/sec</td><td><tt>custom.vfs.dev.write.sectors[{#DEVICENAME}]</tt></td><td>Field #10&#13;
This is the total number of sectors written successfully.</td><td>60</td><td>7d</td><td>182d</td>
</tr>
</table>
</body>
</html>
